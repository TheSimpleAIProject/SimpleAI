{"$message_type":"diagnostic","message":"failed to resolve: could not find `NestedMeta` in `syn`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":462,"byte_end":472,"line_start":16,"line_end":16,"column_start":21,"column_end":31,"is_primary":true,"text":[{"text":"        if let syn::NestedMeta::Meta(syn::Meta::NameValue(name_value)) = arg {","highlight_start":21,"highlight_end":31}],"label":"could not find `NestedMeta` in `syn`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `NestedMeta` in `syn`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:16:21\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if let syn::NestedMeta::Meta(syn::Meta::NameValue(name_value)) = arg {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `NestedMeta` in `syn`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `AttributeArgs` in crate `syn`","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/home/sert/.cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.98/src/macros.rs","byte_start":1028,"byte_end":1052,"line_start":36,"line_end":36,"column_start":22,"column_end":46,"is_primary":false,"text":[{"text":"        $(#[$attr])* $pub $struct $name $body","highlight_start":22,"highlight_end":46}],"label":"similarly named struct `Attribute` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/sert/.cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.98/src/attr.rs","byte_start":469,"byte_end":6261,"line_start":19,"line_end":179,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"ast_struct! {","highlight_start":1,"highlight_end":1},{"text":"    /// An attribute, like `#[repr(transparent)]`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// <br>","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Syntax","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Rust has six types of attributes.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// - Outer attributes like `#[repr(transparent)]`. These appear outside or","highlight_start":1,"highlight_end":1},{"text":"    ///   in front of the item they describe.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// - Inner attributes like `#![feature(proc_macro)]`. These appear inside","highlight_start":1,"highlight_end":1},{"text":"    ///   of the item they describe, usually a module.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// - Outer one-line doc comments like `/// Example`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// - Inner one-line doc comments like `//! Please file an issue`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// - Outer documentation blocks `/** Example */`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// - Inner documentation blocks `/*! Please file an issue */`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// The `style` field of type `AttrStyle` distinguishes whether an attribute","highlight_start":1,"highlight_end":1},{"text":"    /// is outer or inner.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Every attribute has a `path` that indicates the intended interpretation","highlight_start":1,"highlight_end":1},{"text":"    /// of the rest of the attribute's contents. The path and the optional","highlight_start":1,"highlight_end":1},{"text":"    /// additional contents are represented together in the `meta` field of the","highlight_start":1,"highlight_end":1},{"text":"    /// attribute in three possible varieties:","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// - Meta::Path &mdash; attributes whose information content conveys just a","highlight_start":1,"highlight_end":1},{"text":"    ///   path, for example the `#[test]` attribute.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// - Meta::List &mdash; attributes that carry arbitrary tokens after the","highlight_start":1,"highlight_end":1},{"text":"    ///   path, surrounded by a delimiter (parenthesis, bracket, or brace). For","highlight_start":1,"highlight_end":1},{"text":"    ///   example `#[derive(Copy)]` or `#[precondition(x < 5)]`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// - Meta::NameValue &mdash; attributes with an `=` sign after the path,","highlight_start":1,"highlight_end":1},{"text":"    ///   followed by a Rust expression. For example `#[path =","highlight_start":1,"highlight_end":1},{"text":"    ///   \"sys/windows.rs\"]`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// All doc comments are represented in the NameValue style with a path of","highlight_start":1,"highlight_end":1},{"text":"    /// \"doc\", as this is how they are processed by the compiler and by","highlight_start":1,"highlight_end":1},{"text":"    /// `macro_rules!` macros.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// #[derive(Copy, Clone)]","highlight_start":1,"highlight_end":1},{"text":"    ///   ~~~~~~Path","highlight_start":1,"highlight_end":1},{"text":"    ///   ^^^^^^^^^^^^^^^^^^^Meta::List","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// #[path = \"sys/windows.rs\"]","highlight_start":1,"highlight_end":1},{"text":"    ///   ~~~~Path","highlight_start":1,"highlight_end":1},{"text":"    ///   ^^^^^^^^^^^^^^^^^^^^^^^Meta::NameValue","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// #[test]","highlight_start":1,"highlight_end":1},{"text":"    ///   ^^^^Meta::Path","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// <br>","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Parsing from tokens to Attribute","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// This type does not implement the [`Parse`] trait and thus cannot be","highlight_start":1,"highlight_end":1},{"text":"    /// parsed directly by [`ParseStream::parse`]. Instead use","highlight_start":1,"highlight_end":1},{"text":"    /// [`ParseStream::call`] with one of the two parser functions","highlight_start":1,"highlight_end":1},{"text":"    /// [`Attribute::parse_outer`] or [`Attribute::parse_inner`] depending on","highlight_start":1,"highlight_end":1},{"text":"    /// which you intend to parse.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// [`Parse`]: crate::parse::Parse","highlight_start":1,"highlight_end":1},{"text":"    /// [`ParseStream::parse`]: crate::parse::ParseBuffer::parse","highlight_start":1,"highlight_end":1},{"text":"    /// [`ParseStream::call`]: crate::parse::ParseBuffer::call","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    /// use syn::{Attribute, Ident, Result, Token};","highlight_start":1,"highlight_end":1},{"text":"    /// use syn::parse::{Parse, ParseStream};","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// // Parses a unit struct with attributes.","highlight_start":1,"highlight_end":1},{"text":"    /// //","highlight_start":1,"highlight_end":1},{"text":"    /// //     #[path = \"s.tmpl\"]","highlight_start":1,"highlight_end":1},{"text":"    /// //     struct S;","highlight_start":1,"highlight_end":1},{"text":"    /// struct UnitStruct {","highlight_start":1,"highlight_end":1},{"text":"    ///     attrs: Vec<Attribute>,","highlight_start":1,"highlight_end":1},{"text":"    ///     struct_token: Token![struct],","highlight_start":1,"highlight_end":1},{"text":"    ///     name: Ident,","highlight_start":1,"highlight_end":1},{"text":"    ///     semi_token: Token![;],","highlight_start":1,"highlight_end":1},{"text":"    /// }","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// impl Parse for UnitStruct {","highlight_start":1,"highlight_end":1},{"text":"    ///     fn parse(input: ParseStream) -> Result<Self> {","highlight_start":1,"highlight_end":1},{"text":"    ///         Ok(UnitStruct {","highlight_start":1,"highlight_end":1},{"text":"    ///             attrs: input.call(Attribute::parse_outer)?,","highlight_start":1,"highlight_end":1},{"text":"    ///             struct_token: input.parse()?,","highlight_start":1,"highlight_end":1},{"text":"    ///             name: input.parse()?,","highlight_start":1,"highlight_end":1},{"text":"    ///             semi_token: input.parse()?,","highlight_start":1,"highlight_end":1},{"text":"    ///         })","highlight_start":1,"highlight_end":1},{"text":"    ///     }","highlight_start":1,"highlight_end":1},{"text":"    /// }","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// <p><br></p>","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Parsing from Attribute to structured arguments","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// The grammar of attributes in Rust is very flexible, which makes the","highlight_start":1,"highlight_end":1},{"text":"    /// syntax tree not that useful on its own. In particular, arguments of the","highlight_start":1,"highlight_end":1},{"text":"    /// `Meta::List` variety of attribute are held in an arbitrary `tokens:","highlight_start":1,"highlight_end":1},{"text":"    /// TokenStream`. Macros are expected to check the `path` of the attribute,","highlight_start":1,"highlight_end":1},{"text":"    /// decide whether they recognize it, and then parse the remaining tokens","highlight_start":1,"highlight_end":1},{"text":"    /// according to whatever grammar they wish to require for that kind of","highlight_start":1,"highlight_end":1},{"text":"    /// attribute. Use [`parse_args()`] to parse those tokens into the expected","highlight_start":1,"highlight_end":1},{"text":"    /// data structure.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// [`parse_args()`]: Attribute::parse_args","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// <p><br></p>","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Doc comments","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// The compiler transforms doc comments, such as `/// comment` and `/*!","highlight_start":1,"highlight_end":1},{"text":"    /// comment */`, into attributes before macros are expanded. Each comment is","highlight_start":1,"highlight_end":1},{"text":"    /// expanded into an attribute of the form `#[doc = r\"comment\"]`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// As an example, the following `mod` items are expanded identically:","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    /// # use syn::{ItemMod, parse_quote};","highlight_start":1,"highlight_end":1},{"text":"    /// let doc: ItemMod = parse_quote! {","highlight_start":1,"highlight_end":1},{"text":"    ///     /// Single line doc comments","highlight_start":1,"highlight_end":1},{"text":"    ///     /// We write so many!","highlight_start":1,"highlight_end":1},{"text":"    ///     /**","highlight_start":1,"highlight_end":1},{"text":"    ///      * Multi-line comments...","highlight_start":1,"highlight_end":1},{"text":"    ///      * May span many lines","highlight_start":1,"highlight_end":1},{"text":"    ///      */","highlight_start":1,"highlight_end":1},{"text":"    ///     mod example {","highlight_start":1,"highlight_end":1},{"text":"    ///         //! Of course, they can be inner too","highlight_start":1,"highlight_end":1},{"text":"    ///         /*! And fit in a single line */","highlight_start":1,"highlight_end":1},{"text":"    ///     }","highlight_start":1,"highlight_end":1},{"text":"    /// };","highlight_start":1,"highlight_end":1},{"text":"    /// let attr: ItemMod = parse_quote! {","highlight_start":1,"highlight_end":1},{"text":"    ///     #[doc = r\" Single line doc comments\"]","highlight_start":1,"highlight_end":1},{"text":"    ///     #[doc = r\" We write so many!\"]","highlight_start":1,"highlight_end":1},{"text":"    ///     #[doc = r\"","highlight_start":1,"highlight_end":1},{"text":"    ///      * Multi-line comments...","highlight_start":1,"highlight_end":1},{"text":"    ///      * May span many lines","highlight_start":1,"highlight_end":1},{"text":"    ///      \"]","highlight_start":1,"highlight_end":1},{"text":"    ///     mod example {","highlight_start":1,"highlight_end":1},{"text":"    ///         #![doc = r\" Of course, they can be inner too\"]","highlight_start":1,"highlight_end":1},{"text":"    ///         #![doc = r\" And fit in a single line \"]","highlight_start":1,"highlight_end":1},{"text":"    ///     }","highlight_start":1,"highlight_end":1},{"text":"    /// };","highlight_start":1,"highlight_end":1},{"text":"    /// assert_eq!(doc, attr);","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(any(feature = \"full\", feature = \"derive\"))))]","highlight_start":1,"highlight_end":1},{"text":"    pub struct Attribute {","highlight_start":1,"highlight_end":1},{"text":"        pub pound_token: Token![#],","highlight_start":1,"highlight_end":1},{"text":"        pub style: AttrStyle,","highlight_start":1,"highlight_end":1},{"text":"        pub bracket_token: token::Bracket,","highlight_start":1,"highlight_end":1},{"text":"        pub meta: Meta,","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"ast_struct!","def_site_span":{"file_name":"/home/sert/.cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.98/src/macros.rs","byte_start":112,"byte_end":135,"line_start":5,"line_end":5,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! ast_struct {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":361,"byte_end":374,"line_start":11,"line_end":11,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"    let args = parse_macro_input!(attr as syn::AttributeArgs);","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a struct with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":361,"byte_end":374,"line_start":11,"line_end":11,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"    let args = parse_macro_input!(attr as syn::AttributeArgs);","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":"Attribute","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `AttributeArgs` in crate `syn`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:11:48\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    let args = parse_macro_input!(attr as syn::AttributeArgs);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: a struct with a similar name exists: `Attribute`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/sert/.cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.98/src/attr.rs:19:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mast_struct! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// An attribute, like `#[repr(transparent)]`.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// <br>\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m179\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12msimilarly named struct `Attribute` defined here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `ExprAssign`, `ExprLit`, `Expr`, `LitStr`, and `Lit`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":170,"byte_end":174,"line_start":7,"line_end":7,"column_start":30,"column_end":34,"is_primary":true,"text":[{"text":"use syn::{parse_macro_input, Expr, ExprAssign, ExprLit, ItemFn, Lit, LitStr};","highlight_start":30,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":176,"byte_end":186,"line_start":7,"line_end":7,"column_start":36,"column_end":46,"is_primary":true,"text":[{"text":"use syn::{parse_macro_input, Expr, ExprAssign, ExprLit, ItemFn, Lit, LitStr};","highlight_start":36,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":188,"byte_end":195,"line_start":7,"line_end":7,"column_start":48,"column_end":55,"is_primary":true,"text":[{"text":"use syn::{parse_macro_input, Expr, ExprAssign, ExprLit, ItemFn, Lit, LitStr};","highlight_start":48,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":205,"byte_end":208,"line_start":7,"line_end":7,"column_start":65,"column_end":68,"is_primary":true,"text":[{"text":"use syn::{parse_macro_input, Expr, ExprAssign, ExprLit, ItemFn, Lit, LitStr};","highlight_start":65,"highlight_end":68}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":210,"byte_end":216,"line_start":7,"line_end":7,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"use syn::{parse_macro_input, Expr, ExprAssign, ExprLit, ItemFn, Lit, LitStr};","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":168,"byte_end":195,"line_start":7,"line_end":7,"column_start":28,"column_end":55,"is_primary":true,"text":[{"text":"use syn::{parse_macro_input, Expr, ExprAssign, ExprLit, ItemFn, Lit, LitStr};","highlight_start":28,"highlight_end":55}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/lib.rs","byte_start":203,"byte_end":216,"line_start":7,"line_end":7,"column_start":63,"column_end":76,"is_primary":true,"text":[{"text":"use syn::{parse_macro_input, Expr, ExprAssign, ExprLit, ItemFn, Lit, LitStr};","highlight_start":63,"highlight_end":76}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused imports: `ExprAssign`, `ExprLit`, `Expr`, `LitStr`, and `Lit`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:7:30\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse syn::{parse_macro_input, Expr, ExprAssign, ExprLit, ItemFn, Lit, LitStr};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 2 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 2 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0412, E0433.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0412, E0433.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0412`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0412`.\u001b[0m\n"}
